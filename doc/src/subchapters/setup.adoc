= Setup

This guide covers everything you need to set up and run the FlagForge project locally for development.

== Prerequisites

Before starting, ensure you have the following installed:

[cols="1,2,2"]
|===
| Tool | Version | Notes

| Java
| 21+
| Enforced via Gradle toolchain

| Node.js
| 24.11.1
|

| npm
| 11.6.4+
| Comes with Node.js

| Docker & Docker Compose
| Latest
| Required for containerized development

| Git
| Latest
| Version control
|===

== Quick Start (Docker)

The fastest way to get started is using Docker Compose, which runs all services together:

[source,bash]
----
# Start all services (PostgreSQL, backend APIs, frontend, nginx)
./gradlew dockerUp

# Access the application
open http://localhost
----

The Docker setup includes:

* *PostgreSQL 16* on port 5432
* *Webapp API* (Spring Boot) on port 8080
* *Customer API* (Spring Boot) on port 8081
* *Frontend* (Angular dev server) on port 4200
* *Nginx* reverse proxy on port 80 (main entry point)

=== Docker Commands

All Docker operations are available as Gradle tasks:

[source,bash]
----
./gradlew dockerUp              # Start all containers
./gradlew dockerDown            # Stop all containers
./gradlew dockerRestart         # Restart all containers
./gradlew dockerLogs            # View logs (follow mode)
./gradlew dockerPs              # Show container status
./gradlew dockerBuild           # Build all images
./gradlew dockerClean           # Remove containers, networks, and volumes
./gradlew dockerResetDb         # Reset PostgreSQL volume (data loss!)
./gradlew dockerStartPostgres   # Start only PostgreSQL
----

== Project Structure

[source]
----
flagforge/
├── backend/
│   ├── webapp-api/          # Main Spring Boot API (port 8080)
│   └── customer-api/        # Customer-facing SDK API (port 8081)
├── webapp/                  # Angular frontend
├── deployment/local/        # Docker and nginx configuration
├── contracts/               # Generated OpenAPI specifications
├── system-tests/            # Playwright E2E tests
└── doc/                     # ARC42 documentation
----

== Backend Setup

The backend consists of two Spring Boot services sharing a PostgreSQL database.

=== Build System

The project uses Gradle with Kotlin DSL (`.kts` files):

* `settings.gradle.kts` - Defines project structure and subprojects
* `build.gradle.kts` - Root build file with Docker tasks and dependency management
* `backend/build.gradle.kts` - Shared backend configuration (Java 21, dependency versions)
* `backend/webapp-api/build.gradle.kts` - Webapp API specific dependencies
* `backend/customer-api/build.gradle.kts` - Customer API specific dependencies

=== Webapp API

The main backend service for the UI.
Handles authentication, company/application management, and feature flags.

[cols="1,2"]
|===
| Port | 8080
| Context Path | `/api`
| Database User | `webapp-flagforge`
| Migrations | Flyway (owns all migrations)
|===

==== Running Locally

[source,bash]
----
# Ensure PostgreSQL is running
./gradlew dockerStartPostgres

# Run the service
./gradlew backend:webapp-api:bootRun

# Run tests, postgres is not required for this
./gradlew backend:webapp-api:test
----

=== Customer API

Customer-facing API for SDK integrations.
Read-only access to the database.

[cols="1,2"]
|===
| Port | 8081
| Context Path | `/customer-api`
| Database User | `customer-flagforge` (read-only)
| Migrations | Disabled (webapp-api owns migrations)
|===

==== Running Locally

[source,bash]
----
# Ensure PostgreSQL is running
./gradlew dockerStartPostgres

# Run the service
./gradlew backend:customer-api:bootRun

# Run tests
./gradlew backend:customer-api:test
----

== Webapp Setup

The frontend is an Angular 21 application using standalone components.

=== Tooling

[cols="1,1"]
|===
| Tool | Version

| Angular | 21
| TypeScript | 5.9.2 (strict mode)
| Testing | Vitest 4.0.8
| API Client | ng-openapi-gen
| Styling | SCSS
|===

=== Running Locally

[source,bash]
----
cd webapp

# Install dependencies
npm install

# Start dev server (port 4200)
npm start

# Run tests
npm test

# Production build
npm run build
----

=== Directory Structure

[source]
----
webapp/src/
├── app/
│   ├── api/generated/       # Auto-generated TypeScript API client
│   ├── components/          # Reusable UI components
│   ├── guards/              # Route guards (authGuard)
│   ├── interceptors/        # HTTP interceptors (authInterceptor)
│   ├── layouts/             # Page layouts
│   ├── pages/               # Route-level components
│   ├── services/            # Singleton services
│   ├── utils/               # Utility functions
│   ├── app.component.ts     # Root component
│   ├── app.routes.ts        # Routing definitions
│   └── app.config.ts        # App configuration
├── styles/                  # Global SCSS system
├── environments/            # Environment configuration
└── index.html
----

=== Environment Configuration

[cols="1,2"]
|===
| File | API Base URL

| `environment.ts` (dev) | `/api` (proxied via nginx)
| `environment.prod.ts` | `http://localhost:80/api`
|===

== Database Setup

=== PostgreSQL Configuration

[cols="1,2"]
|===
| Database | `flagforge`
| Port | 5432
| Admin User | `flagforge / flagforge`
|===

=== Database Users

The Docker setup creates two application users with different permissions:

[cols="1,2,2"]
|===
| User | Password | Permissions

| `webapp-flagforge`
| `webapp-flagforge`
| Full CRUD, can run migrations, create tables

| `customer-flagforge`
| `customer-flagforge`
| SELECT only (read-only access)
|===

User creation script: `deployment/local/postgres/init-users.sql`

=== Migrations

Database migrations are managed by Flyway and owned by the `webapp-api` service.

Location: `backend/webapp-api/src/main/resources/db/migration/`

Naming convention: `V{version}__{description}.sql`

Example migrations:

[source]
----
V1.0.1__create_user_table.sql
V1.0.2__create_company_table.sql
V1.0.3__create_application_table.sql
...
----

== API Documentation & Code Generation

=== Generating OpenAPI Specs

The backend services generate OpenAPI 3.0 specifications that are stored in the `contracts/` folder:

[source,bash]
----
# Generate webapp API spec
./gradlew backend:webapp-api:generateOpenApiDocs

# Generate customer API spec
./gradlew backend:customer-api:generateOpenApiDocs
----

Output files:

* `contracts/webapp_api.json`
* `contracts/customer_api.json`

=== Generating TypeScript Client

The frontend uses auto-generated TypeScript code from the OpenAPI specs:

[source,bash]
----
# Clean and regenerate TypeScript client
./gradlew webapp:cleanGenerated && ./gradlew webapp:generateTypeScriptClient

# Or from the webapp folder
cd webapp && npm run generate-api
----

Generated code location: `webapp/src/app/api/generated/`

[NOTE]
====
Always regenerate the TypeScript client after making changes to the backend API.
====

== Testing

FlagForge has a comprehensive test suite covering unit tests, integration tests, architecture tests, and end-to-end system tests.

=== Test Overview

[cols="1,2,2,2"]
|===
| Type | Framework | Location | Command

| Backend Unit Tests
| JUnit 5, Mockito
| `backend/webapp-api/src/test/java/.../service/`
| `./gradlew backend:webapp-api:test`

| Backend Integration Tests
| JUnit 5, Testcontainers
| `backend/webapp-api/src/test/java/.../controller/`
| `./gradlew backend:webapp-api:test`

| Architecture Tests
| ArchUnit
| `backend/webapp-api/src/test/java/.../architecture/`
| `./gradlew backend:webapp-api:architectureTest`

| Frontend Unit Tests
| Vitest
| `webapp/src/**/*.spec.ts`
| `./gradlew frontendTests`

| System Tests (E2E)
| Playwright
| `system-tests/tests/`
| `./gradlew systemTests`

| *All Tests*
| *All frameworks*
| *All locations*
| `./gradlew allTests`
|===

=== Email Testing with Mailpit

For local development, all outgoing emails are captured by https://mailpit.axllent.org/[Mailpit], a lightweight email testing tool.

[cols="1,2"]
|===
| Web UI | http://localhost:8025
| SMTP Port | 1025
|===

To view emails sent by the application (registration confirmations, password resets, team invitations, etc.):

[source,bash]
----
# Ensure Docker is running
./gradlew dockerUp

# Open the Mailpit web interface
open http://localhost:8025
----

The Mailpit UI allows you to:

* View all captured emails
* Inspect email content (HTML and plain text)
* Check email headers
* Search through emails
* Delete individual emails or clear all

[NOTE]
====
Mailpit is only available in the local Docker environment.
No emails are sent to real addresses during local development.
====

=== Backend Tests

==== Unit Tests

Unit tests mock dependencies and test business logic in isolation.

Location: `backend/webapp-api/src/test/java/io/hephaistos/flagforge/service/`

[source]
----
service/
├── DefaultApiKeyServiceTest.java
├── DefaultApplicationServiceTest.java
├── DefaultEnvironmentServiceTest.java
├── DefaultJwtServiceTest.java
└── CustomerServiceTest.java
----

[source,bash]
----
# Run all backend tests (unit + integration)
./gradlew backend:webapp-api:test

# Run only unit tests
./gradlew backend:webapp-api:test --tests "*Test" -x architectureTest
----

==== Integration Tests

Integration tests use Testcontainers to spin up a real PostgreSQL database and test the full request/response cycle.

Location: `backend/webapp-api/src/test/java/io/hephaistos/flagforge/controller/`

[source]
----
controller/
├── ApiKeyControllerIntegrationTest.java
├── ApplicationControllerIntegrationTest.java
├── AuthorizationControllerIntegrationTest.java
├── CustomerControllerIntegrationTest.java
└── EnvironmentControllerIntegrationTest.java
----

[source,bash]
----
# Run integration tests (requires Docker for Testcontainers)
./gradlew backend:webapp-api:test --tests "*IntegrationTest"
----

==== Architecture Tests

Architecture tests use ArchUnit to enforce coding standards and multi-tenancy security rules.

Location: `backend/webapp-api/src/test/java/io/hephaistos/flagforge/architecture/`

[source,bash]
----
# Run architecture tests only
./gradlew backend:webapp-api:architectureTest
----

Current rules enforce:

* Services must use `findByIdFiltered()` instead of `findById()` on filtered repositories
* Ensures Hibernate `@Filter` annotations are applied for multi-tenancy isolation

=== Frontend Tests

Frontend unit tests use Vitest with jsdom for DOM simulation.

Location: `webapp/src/**/*.spec.ts`

[source,bash]
----
cd webapp
npm test              # Run tests once
npm test -- --watch   # Watch mode
----

=== System Tests (E2E)

End-to-end tests use Playwright and run against the full Docker environment.

==== Test Location

Location: `system-tests/tests/`

[source]
----
system-tests/tests/
├── auth/
│   ├── login.spec.ts          # Login flow tests
│   └── register.spec.ts       # Registration flow tests
└── application/
    └── api-keys.spec.ts       # API key show/hide/regenerate tests
----

==== Test Coverage

*Auth Tests:*

* Login form validation
* Registration form validation
* Password strength validation
* Successful login/registration flows

*API Key Tests:*

* Keys hidden by default (placeholder dots)
* Show key fetches from backend
* Hide key clears state
* Key regeneration with confirmation modal
* State cleared on environment change

==== Setup

[source,bash]
----
cd system-tests
npm install
----

==== Running Tests

[source,bash]
----
# Via Gradle (starts Docker, runs tests, stops Docker)
./gradlew systemTests

# Or manually (requires Docker environment running)
./gradlew dockerUp    # Start environment first

cd system-tests
npm test                   # Run all tests
npm run test:ui            # Run with UI mode
npm run test:headed        # Run in headed mode
npm run test:chromium      # Run specific browser
npm run test:firefox       # Run Firefox only
npm run test:webkit        # Run Safari only
npm run test:debug         # Debug mode
npm run codegen            # Record new tests
npm run report             # Show HTML report
----

==== Configuration

Tests are configured in `system-tests/playwright.config.ts`:

* Base URL: `http://localhost` (Docker nginx)
* Browsers: Chromium, Firefox, WebKit
* Parallel execution enabled
* Retries: 2 on CI, 0 locally
* Screenshots: On failure
* Video: On first retry

=== Running All Tests

==== Single Command (Recommended)

Run all tests in the correct order with a single Gradle command:

[source,bash]
----
./gradlew allTests
----

This runs tests in the following order:

1. *Architecture tests* - Fast structural checks (no containers)
2. *Backend JUnit tests* - Unit and integration tests (uses Testcontainers)
3. *Frontend Vitest tests* - Angular component and service tests
4. *System tests* - E2E Playwright tests (starts Docker automatically)

[NOTE]
====
The `allTests` task automatically manages Docker for system tests - it starts the environment before E2E tests and stops it after completion.
====

==== Running Tests Individually

[source,bash]
----
# Architecture tests only (fastest)
./gradlew backend:webapp-api:architectureTest

# Backend tests (unit + integration)
./gradlew backend:webapp-api:test
./gradlew backend:customer-api:test

# Frontend tests only
./gradlew frontendTests
# Or: cd webapp && npm test

# System tests only (manages Docker automatically)
./gradlew systemTests
----

== IDE Setup

=== IntelliJ IDEA

. Open the project root folder
. Import as a Gradle project when prompted
. The Gradle view will show all available tasks
. Use the run configurations for Spring Boot applications

[NOTE]
====
IntelliJ will automatically detect and use the correct Java version via the Gradle toolchain configuration.
====

=== VS Code

Recommended extensions:

* Java Extension Pack
* Spring Boot Extension Pack
* Angular Language Service
* ESLint
* Prettier

== Common Tasks Reference

=== Development Workflow

[source,bash]
----
# Start everything with Docker
./gradlew dockerUp

# Or run services individually:
./gradlew dockerStartPostgres          # Database only
./gradlew backend:webapp-api:bootRun   # Backend (terminal 1)
cd webapp && npm start                 # Frontend (terminal 2)
----

=== Backend Development

[source,bash]
----
./gradlew backend:webapp-api:bootRun     # Run webapp-api
./gradlew backend:webapp-api:test        # Run tests
./gradlew backend:customer-api:bootRun   # Run customer-api
./gradlew backend:customer-api:test      # Run tests
./gradlew test                           # Run all backend tests
./gradlew build                          # Build all backend services
----

=== Frontend Development

[source,bash]
----
cd webapp
npm start                                # Dev server on port 4200
npm test                                 # Run unit tests
npm run build                            # Production build
npm run generate-api                     # Regenerate API client
----

=== API & Contract Management

[source,bash]
----
# Generate OpenAPI specs from backend
./gradlew backend:webapp-api:generateOpenApiDocs
./gradlew backend:customer-api:generateOpenApiDocs

# Generate frontend TypeScript client
./gradlew webapp:cleanGenerated && ./gradlew webapp:generateTypeScriptClient
----

== Load Testing

The project includes a k6 load testing script to simulate traffic to the customer-api.
This is useful for testing usage statistics tracking and rate limiting behavior.

=== Prerequisites

Install k6:

[source,bash]
----
brew install k6
----

=== Running Load Tests

Basic usage with an API key:

[source,bash]
----
k6 run -e API_KEY="your-api-key" --vus 10 --duration 1m load-tests/load-test.k6.js
----

Sine wave traffic pattern (oscillates between MIN_RPS and MAX_RPS):

[source,bash]
----
k6 run \
  -e API_KEY="your-api-key" \
  -e PATTERN="sine" \
  -e PERIOD="30" \
  -e MIN_RPS="5" \
  -e MAX_RPS="30" \
  --duration 2m \
  load-tests/load-test.k6.js
----

Ramp pattern (gradually increases from MIN_RPS to MAX_RPS):

[source,bash]
----
k6 run \
  -e API_KEY="your-api-key" \
  -e PATTERN="ramp" \
  -e MIN_RPS="1" \
  -e MAX_RPS="50" \
  --duration 3m \
  load-tests/load-test.k6.js
----

Test user endpoints (cycle through multiple user IDs):

[source,bash]
----
k6 run \
  -e API_KEY="your-api-key" \
  -e USER_COUNT="10" \
  --vus 15 --duration 2m \
  load-tests/load-test.k6.js
----

=== Configuration Options

[cols="1,2,1"]
|===
| Variable | Description | Default

| `API_KEY`
| API key (required)
| -

| `BASE_URL`
| Base URL for customer-api
| `http://localhost:8081`

| `PATTERN`
| Traffic pattern: `constant`, `sine`, `ramp`
| `constant`

| `PERIOD`
| Sine wave period in seconds
| `60`

| `MIN_RPS`
| Minimum requests per second
| `5`

| `MAX_RPS`
| Maximum requests per second
| `50`

| `IDENTIFIER`
| System identifier for requests
| (none)

| `USER_COUNT`
| Number of user IDs to cycle through
| `0`
|===

=== Output Metrics

k6 displays real-time metrics including:

* *http_req_duration*: Response time statistics (avg, min, max, p90, p95)
* *http_reqs*: Total requests and requests/sec
* *errors*: Error rate percentage
* *iterations*: How many times the script ran

To save results as JSON:

[source,bash]
----
k6 run -e API_KEY="your-key" --out json=results.json load-tests/load-test.k6.js
----

== Troubleshooting

=== Port Already in Use

If services fail to start due to port conflicts:

[source,bash]
----
# Check what's using the port
lsof -i :8080

# Kill the process or stop Docker containers
./gradlew dockerDown
----

=== Database Connection Issues

[source,bash]
----
# Reset the database
./gradlew dockerResetDb

# Restart PostgreSQL
./gradlew dockerDown
./gradlew dockerStartPostgres
----

=== Frontend Not Loading

. Check that nginx is running: `./gradlew dockerPs`
. Check logs: `./gradlew dockerLogs`
. Ensure the backend is healthy (nginx waits for backend health checks)

=== Gradle Build Issues

[source,bash]
----
# Clean all build artifacts
./gradlew clean

# Refresh dependencies
./gradlew --refresh-dependencies build
----

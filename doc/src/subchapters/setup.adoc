= Setup

This guide covers everything you need to set up and run the FlagForge project locally for development.

== Prerequisites

Before starting, ensure you have the following installed:

[cols="1,2,2"]
|===
| Tool | Version | Notes

| Java
| 21+
| Enforced via Gradle toolchain

| Node.js
| 24.11.1
|

| npm
| 11.6.4+
| Comes with Node.js

| Docker & Docker Compose
| Latest
| Required for containerized development

| Git
| Latest
| Version control
|===

== Quick Start (Docker)

The fastest way to get started is using Docker Compose, which runs all services together:

[source,bash]
----
# Start all services (PostgreSQL, backend APIs, frontend, nginx)
./gradlew dockerUp

# Access the application
open http://localhost
----

The Docker setup includes:

* *PostgreSQL 16* on port 5432
* *Webapp API* (Spring Boot) on port 8080
* *Customer API* (Spring Boot) on port 8081
* *Frontend* (Angular dev server) on port 4200
* *Nginx* reverse proxy on port 80 (main entry point)

=== Docker Commands

All Docker operations are available as Gradle tasks:

[source,bash]
----
./gradlew dockerUp              # Start all containers
./gradlew dockerDown            # Stop all containers
./gradlew dockerRestart         # Restart all containers
./gradlew dockerLogs            # View logs (follow mode)
./gradlew dockerPs              # Show container status
./gradlew dockerBuild           # Build all images
./gradlew dockerClean           # Remove containers, networks, and volumes
./gradlew dockerResetDb         # Reset PostgreSQL volume (data loss!)
./gradlew dockerStartPostgres   # Start only PostgreSQL
----

== Project Structure

[source]
----
flagforge/
├── backend/
│   ├── webapp-api/          # Main Spring Boot API (port 8080)
│   └── customer-api/        # Customer-facing SDK API (port 8081)
├── webapp/                  # Angular frontend
├── deployment/local/        # Docker and nginx configuration
├── contracts/               # Generated OpenAPI specifications
├── system-tests/            # Playwright E2E tests
└── doc/                     # ARC42 documentation
----

== Backend Setup

The backend consists of two Spring Boot services sharing a PostgreSQL database.

=== Build System

The project uses Gradle with Kotlin DSL (`.kts` files):

* `settings.gradle.kts` - Defines project structure and subprojects
* `build.gradle.kts` - Root build file with Docker tasks and dependency management
* `backend/build.gradle.kts` - Shared backend configuration (Java 21, dependency versions)
* `backend/webapp-api/build.gradle.kts` - Webapp API specific dependencies
* `backend/customer-api/build.gradle.kts` - Customer API specific dependencies

=== Webapp API

The main backend service for the UI.
Handles authentication, company/application management, and feature flags.

[cols="1,2"]
|===
| Port | 8080
| Context Path | `/api`
| Database User | `webapp-flagforge`
| Migrations | Flyway (owns all migrations)
|===

==== Running Locally

[source,bash]
----
# Ensure PostgreSQL is running
./gradlew dockerStartPostgres

# Run the service
./gradlew backend:webapp-api:bootRun

# Run tests, postgres is not required for this
./gradlew backend:webapp-api:test
----

=== Customer API

Customer-facing API for SDK integrations.
Read-only access to the database.

[cols="1,2"]
|===
| Port | 8081
| Context Path | `/customer-api`
| Database User | `customer-flagforge` (read-only)
| Migrations | Disabled (webapp-api owns migrations)
|===

==== Running Locally

[source,bash]
----
# Ensure PostgreSQL is running
./gradlew dockerStartPostgres

# Run the service
./gradlew backend:customer-api:bootRun

# Run tests
./gradlew backend:customer-api:test
----

== Webapp Setup

The frontend is an Angular 21 application using standalone components.

=== Tooling

[cols="1,1"]
|===
| Tool | Version

| Angular | 21
| TypeScript | 5.9.2 (strict mode)
| Testing | Vitest 4.0.8
| API Client | ng-openapi-gen
| Styling | SCSS
|===

=== Running Locally

[source,bash]
----
cd webapp

# Install dependencies
npm install

# Start dev server (port 4200)
npm start

# Run tests
npm test

# Production build
npm run build
----

=== Directory Structure

[source]
----
webapp/src/
├── app/
│   ├── api/generated/       # Auto-generated TypeScript API client
│   ├── components/          # Reusable UI components
│   ├── guards/              # Route guards (authGuard)
│   ├── interceptors/        # HTTP interceptors (authInterceptor)
│   ├── layouts/             # Page layouts
│   ├── pages/               # Route-level components
│   ├── services/            # Singleton services
│   ├── utils/               # Utility functions
│   ├── app.component.ts     # Root component
│   ├── app.routes.ts        # Routing definitions
│   └── app.config.ts        # App configuration
├── styles/                  # Global SCSS system
├── environments/            # Environment configuration
└── index.html
----

=== Environment Configuration

[cols="1,2"]
|===
| File | API Base URL

| `environment.ts` (dev) | `/api` (proxied via nginx)
| `environment.prod.ts` | `http://localhost:80/api`
|===

== Database Setup

=== PostgreSQL Configuration

[cols="1,2"]
|===
| Database | `flagforge`
| Port | 5432
| Admin User | `flagforge / flagforge`
|===

=== Database Users

The Docker setup creates two application users with different permissions:

[cols="1,2,2"]
|===
| User | Password | Permissions

| `webapp-flagforge`
| `webapp-flagforge`
| Full CRUD, can run migrations, create tables

| `customer-flagforge`
| `customer-flagforge`
| SELECT only (read-only access)
|===

User creation script: `deployment/local/postgres/init-users.sql`

=== Migrations

Database migrations are managed by Flyway and owned by the `webapp-api` service.

Location: `backend/webapp-api/src/main/resources/db/migration/`

Naming convention: `V{version}__{description}.sql`

Example migrations:

[source]
----
V1.0.1__create_user_table.sql
V1.0.2__create_company_table.sql
V1.0.3__create_application_table.sql
...
----

== API Documentation & Code Generation

=== Generating OpenAPI Specs

The backend services generate OpenAPI 3.0 specifications that are stored in the `contracts/` folder:

[source,bash]
----
# Generate webapp API spec
./gradlew backend:webapp-api:generateOpenApiDocs

# Generate customer API spec
./gradlew backend:customer-api:generateOpenApiDocs
----

Output files:

* `contracts/webapp_api.json`
* `contracts/customer_api.json`

=== Generating TypeScript Client

The frontend uses auto-generated TypeScript code from the OpenAPI specs:

[source,bash]
----
# Clean and regenerate TypeScript client
./gradlew webapp:cleanGenerated && ./gradlew webapp:generateTypeScriptClient

# Or from the webapp folder
cd webapp && npm run generate-api
----

Generated code location: `webapp/src/app/api/generated/`

[NOTE]
====
Always regenerate the TypeScript client after making changes to the backend API.
====

== System Tests (E2E)

End-to-end tests use Playwright and run against the full Docker environment.

=== Setup

[source,bash]
----
cd system-tests
npm install
----

=== Running Tests

[source,bash]
----
# Via Gradle (starts Docker, runs tests, stops Docker)
./gradlew systemTests

# Or manually
cd system-tests
npm test                   # Run all tests
npm run test:ui            # Run with UI mode
npm run test:headed        # Run in headed mode
npm run test:chromium      # Run specific browser
npm run test:debug         # Debug mode
npm run codegen            # Record new tests
npm run report             # Show HTML report
----

=== Configuration

Tests are configured in `system-tests/playwright.config.ts`:

* Base URL: `http://localhost` (Docker nginx)
* Browsers: Chromium, Firefox, WebKit
* Parallel execution enabled
* Retries: 2 on CI, 0 locally

== IDE Setup

=== IntelliJ IDEA

. Open the project root folder
. Import as a Gradle project when prompted
. The Gradle view will show all available tasks
. Use the run configurations for Spring Boot applications

[NOTE]
====
IntelliJ will automatically detect and use the correct Java version via the Gradle toolchain configuration.
====

=== VS Code

Recommended extensions:

* Java Extension Pack
* Spring Boot Extension Pack
* Angular Language Service
* ESLint
* Prettier

== Common Tasks Reference

=== Development Workflow

[source,bash]
----
# Start everything with Docker
./gradlew dockerUp

# Or run services individually:
./gradlew dockerStartPostgres          # Database only
./gradlew backend:webapp-api:bootRun   # Backend (terminal 1)
cd webapp && npm start                 # Frontend (terminal 2)
----

=== Backend Development

[source,bash]
----
./gradlew backend:webapp-api:bootRun     # Run webapp-api
./gradlew backend:webapp-api:test        # Run tests
./gradlew backend:customer-api:bootRun   # Run customer-api
./gradlew backend:customer-api:test      # Run tests
./gradlew test                           # Run all backend tests
./gradlew build                          # Build all backend services
----

=== Frontend Development

[source,bash]
----
cd webapp
npm start                                # Dev server on port 4200
npm test                                 # Run unit tests
npm run build                            # Production build
npm run generate-api                     # Regenerate API client
----

=== API & Contract Management

[source,bash]
----
# Generate OpenAPI specs from backend
./gradlew backend:webapp-api:generateOpenApiDocs
./gradlew backend:customer-api:generateOpenApiDocs

# Generate frontend TypeScript client
./gradlew webapp:cleanGenerated && ./gradlew webapp:generateTypeScriptClient
----

== Troubleshooting

=== Port Already in Use

If services fail to start due to port conflicts:

[source,bash]
----
# Check what's using the port
lsof -i :8080

# Kill the process or stop Docker containers
./gradlew dockerDown
----

=== Database Connection Issues

[source,bash]
----
# Reset the database
./gradlew dockerResetDb

# Restart PostgreSQL
./gradlew dockerDown
./gradlew dockerStartPostgres
----

=== Frontend Not Loading

. Check that nginx is running: `./gradlew dockerPs`
. Check logs: `./gradlew dockerLogs`
. Ensure the backend is healthy (nginx waits for backend health checks)

=== Gradle Build Issues

[source,bash]
----
# Clean all build artifacts
./gradlew clean

# Refresh dependencies
./gradlew --refresh-dependencies build
----

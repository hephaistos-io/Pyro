ifndef::imagesdir[:imagesdir: ../images]

[[section-introduction-and-goals]]
= Introduction and Goals

This documentation serves not only as a technical documentation for implementations, decisions as well as integrations, but also as documentation for the less technical parts of the project.
This can there for contain content regarding user behaviour, business related calculations and so forth.

== Why are we developing Pyro?

The idea of Pyro is simple.
Modern systems are often bound to configurations that define their usability.
Generally speaking, it is normal for releases of software products to introduce new features into the codebase, which are initially turned off by so-called _feature flags_.
Once everything else is ready, flipping the flag activates the feature for the system.

By itself this is a relatively basic feature.
A simple _on/off_ switch, so to say.
But the growing complexity and requirements from business often end up with hugely complicated setups.
Suddenly, it's not _either on or off_, but it can be something in between.
Or it's a value that is used as input for a given functionality.

As long as the system you support is limited to one _userbase_, this remains an acceptable effort for companies.
In certain cases, this does not remain like this.
Take for example a platform, that serves multiple countries and deals with local regulations.
The fact alone that each country has different currencies, or minimum invoice durations leads to the requirement of creating such a _configuration of feature flags_ per region.

If you now go one level lower you have the granularity of users.
Whilst this can still be done, it's a huge effort to create a reliable, maintainable system for this.
Oftentimes this collides with priorities; business wants a fast time to market, the technicalities of such solutions is none of their concern.
To some degree, this can also be viewed as a question of opex vs capex; do I want to invest a large amount of money now, at once, that only provides scaffolding for the future, or do I want to spend this budget into sellable functionality?

At the same time, the more granular these _configurations of feature flags_ get, the more business is involved in them.
Who has them turned on?
Which values are set for who?
When do we turn them off?

Generally speaking, at this point in time the responsibility of creating and setting such flags is moved over to business.
This requires additional effort; business personal will not want to meddle with developer level tooling, but will expect a comfortable dashboard and system to do this from, which also provides analytics to some degree.

_Pyro_ aims to solve this issue by abstracting away this functionality.
Customers delegate this to us, so their internal development can focus on delivering features that generate actual monetary value.
This is done by offering
_configurable feature flags_ down to the user level - including templating, usage metrics and a simple API.

== What does "Pyro" even mean?

Pyro stands for "fire".
In this case, we draw the connection to greek mythology, where _Prometheus_ handed humanity fire, which allowed them to prosper.
In this case, we want to achieve the same with _Pyro_: Allow business to focus on prospering.

== Requirements Overview

Requirements are usually not technology bound.
This means they should normally not contain technical details, but focus on the requirement that business / users have.
For example, "As a user, I want the app to automatically be in my language".

Once such a requirement is defined, it has to be broken down into feasible technical options, and a solution has to be selected.
In case it's not feasible, it is of utmost importance to document this for those who come after.

== Flow concept

The following two diagrams demonstrate the rough idea/concept behind Pyro. They are by no means final or to be taken as correct.


ifdef::env-github[]
:MERMAID: source, mermaid
endif::[]
ifndef::env-github[]
:MERMAID: mermaid
endif::[]

[{MERMAID}]
....
graph TB
    subgraph "Pyro Platform"
        Dashboard[["ðŸ–¥ï¸ Pyro Dashboard"]]
        API[["ðŸ”Œ Pyro API"]]
        
        subgraph "Data Storage"
            AppConfig[(Application Config)]
            DefaultFlags[(Default Flags)]
            UserFlags[(User-Specific Flags)]
        end
        
        subgraph "API Endpoints"
            GET["GET /flags/{userId}"]
            POST["POST /flags/{userId}"]
            PATCH["PATCH /flags/{userId}"]
        end
    end
    
    subgraph "Customer Side"
        Customer[ðŸ‘¤ Customer/Developer]
        CustomerApp[["ðŸ“± Customer Application"]]
        EndUser1[ðŸ‘¥ End User 1]
        EndUser2[ðŸ‘¥ End User 2]
        EndUserN[ðŸ‘¥ End User N]
    end
    
    %% Setup Flow
    Customer -->|"1. Register App"| Dashboard
    Dashboard -->|"2. Create App Config"| AppConfig
    Customer -->|"3. Define Default Flags"| Dashboard
    Dashboard -->|"4. Store Defaults"| DefaultFlags
    
    %% Runtime Flow
    EndUser1 -->|"Uses"| CustomerApp
    EndUser2 -->|"Uses"| CustomerApp
    EndUserN -->|"Uses"| CustomerApp
    
    CustomerApp -->|"5. Request User Flags"| GET
    GET -->|"Check User Flags"| UserFlags
    UserFlags -->|"If not exists, use"| DefaultFlags
    GET -->|"6. Return Flags"| CustomerApp
    
    CustomerApp -->|"7. Create/Update User Flags"| POST
    POST -->|"Store"| UserFlags
    
    CustomerApp -->|"8. Modify User Flags"| PATCH
    PATCH -->|"Update"| UserFlags
    
    %% Styling
    classDef platform fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef customer fill:#fff3e0,stroke:#e65100,stroke-width:2px
    classDef storage fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef api fill:#e8f5e9,stroke:#1b5e20,stroke-width:2px
    
    class Dashboard,API platform
    class Customer,CustomerApp,EndUser1,EndUser2,EndUserN customer
    class AppConfig,DefaultFlags,UserFlags storage
    class GET,POST,PATCH api
....

[{MERMAID}]  
.... 
sequenceDiagram
    participant C as Customer
    participant D as Pyro Dashboard
    participant DB as Pyro Database
    participant App as Customer App
    participant API as Pyro API
    participant U as End User
    
    rect rgb(240, 248, 255)
        Note over C,DB: Setup Phase
        C->>D: Login to Dashboard
        C->>D: Create New Application
        D->>DB: Store App Configuration
        C->>D: Define Default Feature Flags
        D->>DB: Store Default Flags
        D-->>C: Application ID & API Keys
    end
    
    rect rgb(255, 250, 240)
        Note over App,U: Runtime Phase
        U->>App: Use Application
        App->>API: GET /flags/{userId}
        API->>DB: Query User Flags
        alt User flags exist
            DB-->>API: Return user-specific flags
        else No user flags
            DB-->>API: Return default flags
        end
        API-->>App: Return flag values
        App-->>U: Render features based on flags
        
        opt Flag Update Needed
            App->>API: POST/PATCH /flags/{userId}
            API->>DB: Update user-specific flags
            API-->>App: Confirmation
        end
    end 
....

:leveloffset: +1

include::subchapters/setup.adoc[]

:leveloffset: -1

== Quality Goals

Reliability:: The service needs to be reachable 24/7 since other applications may not be functional without it
Compatibility:: The service will be integrated into other applications and needs to be widely compatible with many technologies
EaseOfUse:: Pyro is not only catered to the developper and should also be easily configurable for non technical person to create feature sets and administering set sets

== Stakeholders

[options="header",cols="1,2,2"]
|===
|Role/Name|Contact|Expectations
| _<Role-1>_ | _<Contact-1>_ | _<Expectation-1>_
| _<Role-2>_ | _<Contact-2>_ | _<Expectation-2>_
|===
